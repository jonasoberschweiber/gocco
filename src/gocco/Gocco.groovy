/*
 * A documentation generator for Groovy.
 * This is basically a port of [Rocco][ro].
 * 
 * Gocco reads Groovy source files and produces HTML
 * files containing the highlighted and annotated
 * source code. Comments are passed through Markdown.
 * 
 * The supplied 'gocco' script can be used to generated
 * documentation for source files. Call it like this:
 * 
 * 		gocco Gocco.groovy doc.html
 * 
 * [ro]: http://github.com/rtomayko/rocco
 */
package gocco

import com.petebevin.markdown.* 
import com.uwyn.jhighlight.renderer.XhtmlRendererFactory
import groovy.text.GStringTemplateEngine

class Gocco {
	def multilineStart = /^[ \t]*\/\*(.*)/
	def multilineEnd = /(.*)\*\/(.*)/
	def singleline = /^[ \t]*\/\/(.*)/
	def file = ""
	def sections = []
	
	/*
	 * Parse the given file, split it into sections and pass these sections
	 * through Markdown and the Groovy code highlighter. Store the result
	 * in the 'sections' member for the 'toHtml' function to use later on.
	 */
	def parseFile(file) {
		def f = new File(file)
		this.file = f.getName()
		def code = f.text
		sections = highlight(split(parse(code)))	
	} 
	
	/*
	 * Parse the given code line by line into pairs of arrays [code, docs]
	 * holding the raw lines that describe the documentation and code for one
	 * section. 
	 */
	def parse(code) {
		def inMultiline = false
		def lastComment = false
		def currCode = []
		def currComment = []
		sections = []
		code.eachLine { line -> 
			if (line ==~ multilineStart) {
				inMultiline = true	
			}
			if (line ==~ singleline || inMultiline) { 
				if (!lastComment && (currCode.size() > 0 || currComment.size() > 0)) {
					sections << [currCode, currComment]
					currCode = []
					currComment = []
				}
				currComment << line	
				lastComment = true
			} else {
				currCode << line
				lastComment = false
			}
			if (line ==~ multilineEnd) {
				inMultiline = false
			}
		}	
		if (currCode.size() > 0 || currComment.size() > 0) {
			sections << [currCode, currComment]
		}
		return sections
	}
	
	/*
	 * Strip the comment leaders from the documentation in each section.
	 */
	def split(sections) {
		def docs = [], code = []
		sections.each { p -> 
			def d = p[1], c = p[0]
			docs << d.collect { line -> (line =~ /([ \t]*\/\*|[ \t]*\/\/|[ \t]*\*\/?)/).replaceAll("") }.join("\r\n")
			code << c.collect { line -> line }.join("\r\n")
		}
		return [code, docs]
	}
	
	def highlight(blocks) {
		def docs = blocks[1], code = blocks[0]
		
		// Insert divider h5s into the documentation blocks and pass the result through markdown.
		// Split the result up into blocks again.
		def markdown = new MarkdownProcessor()
		docs = markdown.markdown(docs.join("\r\n##### DIVIDER\r\n")).split("<h5>DIVIDER</h5>") as List
		
		// Pass the code through the highlighter. 
		def renderer = XhtmlRendererFactory.getRenderer("groovy") 
		code = code.collect { c -> renderer.highlight("groovy", c, "UTF8", true).replace("<br />", "") }
		
		// Combine the formatted blocks back into one big array
		// of sections.
		def result = []
		(0..<docs.size()).each { i ->
			result << [code[i], docs[i]]
		}
		return result
	}
	
	/*
	 * Take the sections generated by 'parseFile' and its helper functions and pass them
	 * to the template engine, building the final HTML page.
	 */
	def toHtml(tmplPath="template.html") {
		def tmplFile = new File(tmplPath);
		def engine = new GStringTemplateEngine()
		def template = engine.createTemplate(tmplFile).make(["sections" : sections, "title" : file]) 
		return template.toString();
	}
	
	/*
	 * If Gocco is called as a standalone script, the default behavior is
	 * to take the file to be documented as the first and the target path
	 * for the documentation as the second argument.
	 */
	static main(args) {
		def gocco = new Gocco()
		def templateFile = "template.html"
		def argOffset = 0
		if (args[0] == "--template") {
			templateFile = args[1]	
			argOffset = 2
		}
		gocco.parseFile(args[argOffset])
		def outFile = new File(args[argOffset + 1])
		outFile.write(gocco.toHtml(templateFile))
	}
}
